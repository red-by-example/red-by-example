<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional"><html><head><meta http-equiv="content-type" content="text/html;charset=iso-8859-1"><title>Red by Example</title><style type="text/css">html, body, p, td, li {font-family: arial, sans-serif, helvetica; font-size: 10pt;}h1 {font-size: 16pt; Font-Weight: bold;}h2 {font-size: 14pt; color: #2030a0; Font-Weight: bold; width: 100%;    border-bottom: 1px solid #c09060;}h3 {font-size: 12pt; color: #2030a0; Font-Weight: bold;}h4 {font-size: 10pt; color: #2030a0; Font-Weight: bold;}h5 {font-size: 10pt; Font-Weight: bold;}tt {font-family: "courier new", monospace, courier; color: darkgreen;}pre {font: bold 10pt "courier new", monospace, console;    background-color: #f4f6f6; padding: 16px; border: solid #a0a0a0 1px;}.toc1 {margin-left: 1cm; font-size: 12pt; font-weight: bold;}.toc2 {margin-left: 2cm; font-size: 10pt; font-weight: bold; text-decoration: none;}.toc3 {margin-left: 3cm; font-size: 10pt; text-decoration: none;}.toc4 {margin-left: 4cm; font-size: 10pt; color: grey; text-decoration: none;}.output {color: #000080; font-weight: normal;}.note {background-color: #f0e090; width: 100%; padding: 16px; border: solid #a0a0a0 1px;}.tail {color: gray; font-size: 8pt;}.mike-large{color:blue; font-size: 13pt; font-weight:bold; }  .mike-small{ font-size: 10pt; }</style></head><body bgcolor="white"><center><table width="660" cellpadding="4" cellspacing="0" border="0"><tr><td><!----------------------------------------------------------------------------><h1 style="color:red; id=top">Red by Example - an accessible reference by example</h1>Last update on 20-Dec-2019<h2>series</h2><pre><a href="index.html">index</a>     <a href="parse.html">parse</a>     <a href="vid.html">vid</a>     <a href="series.html">series</a>     <a href="draw.html">draw</a>     <a href="help.html">help</a>     <a href="about.html">about</a>     <a href="links.html">links</a>     <a href="contact.html">contact</a>     </pre><pre><a href="#1">1. Introduction</a><br><a href="#2">2. The different types in the series family</a><br><a href="#3">3. Initializing series by using copy</a><br><a href="#4">3.1. Shallow copy of a series</a><br><a href="#5">3.2. Deep copy of a series</a><br><a href="#6">3.3. Initialising a series by using copy</a><br><a href="#7">4. Positioning in a series</a><br><a href="#8">4.1. Positioning in a series - part 1</a><br><a href="#9">4.2. Positioning in a series - part 2</a><br><a href="#10">5. Selecting individual elements in a series</a><br><a href="#11">5.1. Getting an element out of a series</a><br><a href="#12">5.3. Using the at function</a><br><a href="#13">6. Changing individual elements in a series</a><br><a href="#14">7. Looping over a series</a><br><a href="#15">8. Some common tasks with series: sort, find, modify etc.</a><br><a href="#16">8.1. How to sort a series</a><br><a href="#17">8.2. How to find a value in a series</a><br><a href="#18">8.3. How to insert a substring into a string</a><br><a href="#19">8.4. How to replace a substring with another string</a><br><a href="#20">8.5. How to append an item to a series</a><br><a href="#21">8.6. How to get a substring from a series </a><br><a href="#22">8.7. How to join strings</a><br></pre><h2 id="1">1. Introduction</h2><pre><br>The series datatype is a key part of Red.<br>It provides a unified way of accessing ordered series of elements.<br><br>For example, here are some series:<br><br>    "The cat sat down"    <b style="color: green">; a string</b><br><br>    [33 "animal" 22]      <b style="color: green">; a block</b><br><br>    ["The" ["large" "grey"] "cat" "sat" "on" "the" ["cold" "damp"] "floor"]   <b style="color: green">; a block</b><br><br>Elements in blocks are enclosed in [ ] and are separated by spaces.<br><br>Note that blocks can contain variables and elements of mixed types.<br><br>We can refer to particular elements via a (1-based) index.<br>For example, element 2 of each series above is:<br><br>	#"h"                    <b style="color: green">; a single character, not a string</b><br><br>	"animal"                <b style="color: green">; a string</b><br><br>	["large" "grey"]        <b style="color: green">; a block containing 2 strings</b><br><br>A block can contain other blocks.<br><br>Blocks play a key role in the Red language itself.<br>For example, we can write:<br><br>	either 4 &gt; 3 [ print "bigger" ] [ print "not bigger" ]<br><br>The first block contains 2 elements, being "print" and ""bigger"").<br>The second block also contains 2 elements, being "print" and ""not bigger"".<br><br>In fact, Red can treat the above text either as data, or as code!<br><br>Links: <a href="index.html#blockxex">block!</a> <a href="index.html#charxex">char!</a> <a href="index.html#datatypexex">datatype!</a> <a href="index.html#seriesxex">series!</a> <a href="index.html#stringxex">string!</a><br><br><a href="#top">top</a></pre><h2 id="2">2. The different types in the series family</h2><pre><br>Many Red datatypes belong to the series family:<br>	<a href="index.html#blockxex">block!</a> 		<a href="index.html#parenxex">paren!</a> 		<a href="index.html#stringxex">string!</a>		<a href="index.html#filexex">file!</a>		<a href="index.html#urlxex">url!</a>		<a href="index.html#pathxex">path!</a><br>	<a href="index.html#lit-pathxex">lit-path!</a>	<a href="index.html#set-pathxex">set-path!</a> 	<a href="index.html#get-pathxex">get-path!</a> 	<a href="index.html#vectorxex">vector!</a> 	<a href="index.html#hashxex">hash!</a> 		<a href="index.html#binaryxex">binary!</a><br>	<a href="index.html#imagexex">image!</a>		<a href="index.html#tagxex">tag!</a><br><br>So, series functions equally apply to all of those, including strings.<br><br>Here are some examples of series types:<br><br><table width=100% border=1 style="font-family:courier new bold; border-color: blue;"><tr><th>DATATYPE</th><th>EXAMPLE</th></tr><tr><td>binary!</td><td>b: #{FF AA 12}<td></tr><tr><td>block!</td><td>["any" "type" "e.g."  12.23  "Yes" false  [ "nested"] ]<td></tr><tr><td>file!</td><td>%important/my-stuff/programs/<td></tr><tr><td>get-path!</td><td>get-path? first [:a/b/c]<td></tr><tr><td>hash!</td><td><b style="color: green">; to do by Red team</b><td></tr><tr><td>image!</td><td><b style="color: green">; to do by Red team</b><td></tr><tr><td>lit-path!</td><td><b style="color: green">; to do by Red team</b><td></tr><tr><td>paren!</td><td>first [(1 + 2 * 3 / 4)]  <b style="color: green">; inserted in a block to prevent evaluation</b><td></tr><tr><td>path!</td><td>UK/South-east/London/Westminster<td></tr><tr><td>set-path!</td><td>set-path? first [a/b/c: 10]<td></tr><tr><td>string!</td><td>"Some text"<td></tr><tr><td>url!</td><td>http://www.mypages.home/names.html<td></tr><tr><td>vector!</td><td>v-ages: make vector! [80 18 65]<td></tr></table><br>There is also a related map! (dictionary) type, which is not classified as a series.<br><br>Links: <a href="index.html#datatypexex">datatype!</a> <a href="index.html#mapxex">map!</a><br><br><a href="#top">top</a></pre><h2 id="3">3. Initializing series by using copy</h2><pre><br>When working with series, it is important to understand about copy.<br><br>Links: <a href="index.html#copy">copy</a><br><br><a href="#top">top</a></pre><h2 id="4">3.1. Shallow copy of a series</h2><pre><br>When we assign a variable to some series, the series VALUES are NOT copied;<br>instead the REFERENCE to that series is copied into the variable:<br><br>	red>> days: ["sun" ["mon" "tue"] "wed"]<br>	== ["sun" ["mon" "tue"] "wed"]<br><br>	red>> new-days: days<br>	== ["sun" ["mon" "tue"] "wed"]<br><br>	red>> days/1: "fri"<br>	== "fri"    <b style="color: green">; changed first element of <b style="color: blue">days</b></b><br><br>	red>> new-days/1<br>	== "fri"    <b style="color: green">; also changed, because <b style="color: blue">new-days</b> is a reference to same <b style="color: blue">days</b> series</b><br><br>When we want a shallow copy, we must use:<br><br>	red>> days: ["sun" ["mon" "tue"] "wed"]<br>	== ["sun" ["mon" "tue"] "wed"]<br><br>	red>> new-days: copy days<br>	== ["sun" ["mon" "tue"] "wed"]<br><br>	red>> days/1: "fri"<br>	== "fri"    <b style="color: green">; changed first element</b><br><br>	red>> new-days/1<br>	== "sun"    <b style="color: green">; not changed - it is a separate copy</b><br><br>	red>> days/2/1: "thu"<br>	== "thu"    <b style="color: green">; changed "mon" in nested series to "thu"</b><br><br>	red>> new-days/2/1<br>	== "thu"    <b style="color: green">; also changed!!!!!</b><br><br>The last effect is exactly the result of a shallow copy.<br><br>All top level elements except nested series are copied by VALUE. That is why<br>the change to "fri" in the original series did not effect the copied series.<br><br>However, for all nested series only the REFERENCE is copied. That is why the last<br>change (to "thu") in the original series, is visible in the (shallow) copies series.<br><br>Links: <a href="index.html#copy">copy</a><br><br><a href="#top">top</a></pre><h2 id="5">3.2. Deep copy of a series</h2><pre><br>Normal copying does not copy nested series, but we can use the <b style="color: blue">/deep</b> refinement.<br>Instead a shallow copy is made, meaning that for nested series only their REFERENCES<br>are copied!<br><br>Example:<br><br>	red>> s: [11 [222 333 444] 55 66]<br>	== [11 [222 333 444] 55 66]    <b style="color: green">; contains a nested block as element 2</b><br><br>	red>> shallow-copy: copy s<br>	== [11 [222 333 444] 55 66]<br><br>	red>> deep-copy: copy/deep s<br>	== [11 [222 333 444] 55 66]    <b style="color: green">; seems equal to shallow-copy isn't it?</b><br><br>	red>> shallow-copy/2/3: 888    <b style="color: green">; alter the value 444 to 888</b><br>	== 888<br><br>	red>> s<br>	== [11 [222 333 888] 55 66]    <b style="color: green">; original (shallow-copied) series is altered</b><br><br>	red>> shallow-copy<br>	== [11 [222 333 888] 55 66]<br><br>	red>> deep-copy<br>	== [11 [222 333 444] 55 66]    <b style="color: green">; totally different series</b><br><br>Links: <a href="index.html#copy">copy</a><br><br><a href="#top">top</a></pre><h2 id="6">3.3. Initialising a series by using copy</h2><pre><br>As a general rule you should always use copy when you want to initialize a series<br>from a literal value.<br><br>To create e.g. an empty series:<br><br>	results: copy []             <b style="color: green">; an empty block</b><br><br>	student-name: copy ""        <b style="color: green">; an empty string</b><br><br>When you don't do this you will get in trouble. To explain the problem we create a small function:<br><br>	huh: function [] [<br>			list: ""<br>			append list "huh"<br>			print list<br>		 ]<br><br>Now we run this function a few times and see what happens:<br><br>	red>> huh<br>	huh<br><br>	red>> huh<br>	huhhuh<br><br>	red>> huh<br>	huhhuhhuh<br><br>What the heck??! Here is what happens:<br><br>	1. <b style="color: blue">list</b> is a local variable; this is the default in a <b style="color: blue">function</b>;<br>	   note that in a <b style="color: blue">func</b> we need to explicitly declare the variable <b style="color: blue">list</b><br>	   to be local with the /local option.<br><br>	2. when we say:<br>	      list: ""<br>	   the first time we call the function we ask Red to do the following:<br>	   		- allocate some fresh storage for us<br>	   		- initialize that storage with an empty string<br>	   		- ASSIGN that storage PERMANENTLY to the variable <b style="color: blue">list</b><br><br>	3. when we call the function again:<br>	      list: ""<br>	   <b style="color: blue">list</b> will NOT be initialized again; it just has the same contents<br>	   as when the function terminated the last time.<br><br>	4. so, when we alter such series after initializing, the contents will<br>	   be the same as when we left it in the previous function call<br><br>So again, initialize series variables from literals ALWAYS with a copy, UNLESS<br>you wish to use this as a FEATURE.<br><br>As a side note:<br>	The programming language C has STATIC variables (inside functions) which behave<br>	exactly the same. The contents of such variable is kept and can be used in later<br>	function calls.<br><br>Links: <a href="index.html#append">append</a> <a href="index.html#copy">copy</a> <a href="index.html#func">func</a> <a href="index.html#function">function</a><br><br><a href="#top">top</a></pre><h2 id="7">4. Positioning in a series</h2><pre><br>We can walk through series in a forward and backward manner.<br><br><a href="#top">top</a></pre><h2 id="8">4.1. Positioning in a series - part 1</h2><pre><br>A series has a head, a tail and a current index.<br><br>When we initially create our series:<br><br>	red>> days: ["sun" "mon" "tue" "wed"]<br>	== ["sun" "mon" "tue" "wed"]<br><br>Effectively we have this:<br><br>	- the head of the <b style="color: blue">days</b> series always points to the first element<br>	  if there is one. Otherwise head an tail are equal.<br><br>	- variable <b style="color: blue">days</b> currently is at the head of the <b style="color: blue">days</b> series<br><br>	- the tail always points just beyond the last element of a series<br><br>The <b style="color: blue">days</b> variable is kind of a 2-in-1 variable:<br><br>	- it is the name of the series<br><br>	- it is also an index into that same series<br><br>The <b style="color: blue">days</b> variable initially is set to 1 (index is at the head).<br><br>With index? we can request the index where the variable <b style="color: blue">days</b> currently points to.<br><br>Explore the initial state of <b style="color: blue">days</b>:<br><br>	red>> days: ["sun" "mon" "tue" "wed"]<br>	== ["sun" "mon" "tue" "wed"]<br><br>	red>> first days<br>	== "sun"<br><br>	red>> index? days<br>	== 1               <b style="color: green">; value 1 means we are at the head position</b><br><br>	red>> head? days<br>	== true            <b style="color: green">; always in head position if index = 1</b><br><br>	red>> tail? days<br>	== false<br><br>This is as we might expect.  The head? and tail? functions tell us if the<br>index (which is held in the variable <b style="color: blue">days</b>) is currently at the head or<br>at the tail of the <b style="color: blue">days</b> series.<br><br>Now we will use the <a href="index.html#next">next</a> function to increment the index by 1 and explore the state:<br><br>	red>> days: next days<br>	== ["mon" "tue" "wed"]<br><br>	red>> days<br>	== ["mon" "tue" "wed"]<br><br>	red>> first days<br>	== "mon"          <b style="color: green">; <a href="index.html#first">first</a> operates relative to where <b style="color: blue">days</b> currently points to</b><br><br>	red>> index? days<br>	== 2              <b style="color: green">; index now points to "mon"</b><br><br>	red>> head? days<br>	== false          <b style="color: green">; index = 2 (to be in head position index should have been 1)</b><br><br>	red>> tail? days<br>	== false<br><br>The index is now 2, but the first value is now "mon", showing that the functions:<br>first, second, third etc. work relative to the current index value.<br><br>If we position to the <a href="index.html#tail">tail</a> (e.g. by using next several times) we see:<br><br>	red>> days: next next next days<br>	== []             <b style="color: green">; days now points beyond the last element</b><br><br>	red>> first days<br>	== none           <b style="color: green">; there is no <a href="index.html#first">first</a> element - <b style="color: blue">days</b> points to empty series</b><br><br>	red>> index? days<br>	== 5              <b style="color: green">; in the original series there are 4 elements, so we are beyond the last</b><br><br>	red>> head? days<br>	== false<br><br>	red>> tail? days<br>	== true           <b style="color: green">; because index is just beyond the last element</b><br><br>The possibility of going beyond the <a href="index.html#head">head</a> or the <a href="index.html#tail">tail</a> is covered later.<br><br>Links: <a href="index.html#head">head</a> <a href="index.html#headxqm">head?</a> <a href="index.html#indexxqm">index?</a> <a href="index.html#next">next</a> <a href="index.html#tail">tail</a> <a href="index.html#tailxqm">tail?</a> <a href="index.html#first">first</a> <a href="index.html#second">second</a> <a href="index.html#third">third</a> <a href="index.html#fourth">fourth</a> <a href="index.html#fifth">fifth</a><br><br><a href="#top">top</a></pre><h2 id="9">4.2. Positioning in a series - part 2</h2><pre><br>We can position the index at the head or the tail:<br><br>	red>> days: head days<br>	== ["sun" "mon" "tue" "wed"]<br><br>	red>> days: tail days<br>	== []<br><br><br>We can use the back function to do the opposite of next (decrement the index):<br><br>	red>> days: back days<br>	== ["wed"]<br><br>We can use the skip function (with a positive or negative argument) to move the index<br>forward or backward relative to the current index:<br><br>	red>> days: skip days -2<br>	== ["mon" "tue" "wed"]<br><br>	red>> days: skip days 1<br>	== ["tue" "wed"]<br><br>NOTE:<br>	When an attempt is made to move the index to before the head or beyond the tail,<br>	no errors are produced. Red then sets the index to the head or the tail.<br><br>Links: <a href="index.html#back">back</a> <a href="index.html#head">head</a> <a href="index.html#skip">skip</a> <a href="index.html#tail">tail</a><br><br><a href="#top">top</a></pre><h2 id="10">5. Selecting individual elements in a series</h2><pre><br>Given the series:<br><br>	red>> days: ["sun" "mon" "tue" "wed"]<br>	== ["sun" "mon" "tue" "wed"]<br><br>Initially, the <b style="color: blue">days</b> variable is at the head (index = 1).<br><br>To access individual items, there are several possibilities.<br><br>Links: <a href="index.html#head">head</a><br><br><a href="#top">top</a></pre><h2 id="11">5.1. Getting an element out of a series</h2><pre><br>Example using the pick function:<br><br>	red>> days: ["sun" "mon" "tue" "wed"]<br>	== ["sun" "mon" "tue" "wed"]<br><br>	red>> chosen: pick days 3<br>	== "tue"<br><br>	red>> n: 4<br>	== 4<br><br>	red>> chosen: pick days n<br>	== "wed"<br><br>The pick function works relative to the index variable <b style="color: blue">days</b>:<br><br>	red>> days: next days<br>	== ["mon" "tue" "wed"]<br><br>	red>> index? days<br>	== 2<br><br>	red>> pick days 3<br>	== "wed"            <b style="color: green">; relative to the index <b style="color: blue">days</b> points to</b><br><br>	red>> n: 4<br>	== 4<br><br>	red>> pick days n<br>	== none             <b style="color: green">; we now are at tail position</b><br><br>Here pick is used to access a nested series, using variables:<br><br>	red>> s: [1 2 [33 99] 5]<br>	== [1 2 [33 99] 5]<br><br>	red>> m: 3<br>	== 3<br><br>	red>> n: 2<br>	== 2<br><br>	red>> pick pick s m n<br>	== 99<br><br>We can also use path notation:<br><br>	red>> days: ["sun" "mon" "tue" "wed"]<br>	== ["sun" "mon" "tue" "wed"]<br><br>	red>> days/2        <b style="color: green">; 2 is the number of the element we want</b><br>	== "mon"<br><br>A path can also be used to change an element, as in:<br><br>	red>> days/2: "fri"<br>	== "fri"<br><br>	red>> days<br>	== ["sun" "fri" "tue" "wed"]<br><br>Also using a path using a variable:<br><br>	red>> s: [1 2 3 4]<br>	== [1 2 3 4]<br><br>	red>> i: 3<br>	== 3<br><br>	red>> s/:i: 33     <b style="color: green">; note that we need get-word notation here</b><br>	== 33<br><br>	red>> s<br>	== [1 2 33 4]<br><br>Path notation can also be used to access nested series, as in:<br><br>	red>> s: [1 2 [33 34 35] 4]<br>	== [1 2 [33 34 35] 4]     <b style="color: green">; a nested series</b><br><br>	red>> i: 3                <b style="color: green">; used to point to element in top-level series -> [33 34 35]</b><br>	== 3<br><br>	red>> j: 2                <b style="color: green">; used to point to element in second-level series -> 34</b><br>	== 2<br><br>	red>> s/:i/:j: 124<br>	== 124<br><br>	red>> s<br>	== [1 2 [33 124 35] 4]    <b style="color: green">; second-level series has changed indeed</b><br><br>We can use the pre-defined functions: first, second, third, fourth and fifth<br>to access an element (note that these functions operate relative to the index the series<br>currently points to):<br><br>	red>> s: [11 12 13 14 15 16]<br>	== [11 12 13 14 15 16]<br><br>	red>> first s<br>	== 11<br><br>	red>> second s<br>	== 12<br><br>	red>> third s<br>	== 13<br><br>	red>> fourth s<br>	== 14<br><br>	red>> fifth s<br>	== 15<br><br>Links: <a href="index.html#indexxqm">index?</a> <a href="index.html#pathxex">path!</a> <a href="index.html#pick">pick</a> <a href="index.html#first">first</a> <a href="index.html#second">second</a> <a href="index.html#third">third</a> <a href="index.html#fourth">fourth</a> <a href="index.html#fifth">fifth</a><br><br><a href="#top">top</a></pre><h2 id="12">5.3. Using the at function</h2><pre><br>This function returns a reference to the rest of the series starting with the element<br>its argument points to:<br><br>	red>> days: ["sun" "mon" "tue" "wed"]<br>	== ["sun" "mon" "tue" "wed"]<br><br>	red>> at days 3<br>	== ["tue" "wed"]<br><br>This function also works relative to the index of a series.<br><br>Links: <a href="index.html#at">at</a><br><br><a href="#top">top</a></pre><h2 id="13">6. Changing individual elements in a series</h2><pre><br>Example:<br><br>	red>> days: ["sun" "mon" "tue" "wed"]<br>	== ["sun" "mon" "tue" "wed"]<br><br>	red>> poke days 2 "fri"<br>	== "fri"        <b style="color: green">; note that poke returns the new element value</b><br><br>	red>> days<br>	== ["sun" "fri" "tue" "wed"]<br><br>To change nested elements we must use path notation as shown earlier on this page<br><br>Links: <a href="index.html#poke">poke</a><br><br><a href="#top">top</a></pre><h2 id="14">7. Looping over a series</h2><pre><br>Making use of Red's powerful series functions will minimize your use of loops,<br>but should you need to do this, here is an example using <a href="index.html#foreach">foreach</a>:<br><br>	red>> days: ["sun" "mon" "tue" "wed"]<br>	== ["sun" "mon" "tue" "wed"]<br><br>	red>> foreach day days [ print day ]<br>	<b style="color: blue">sun</b><br>	<b style="color: blue">mon</b><br>	<b style="color: blue">tue</b><br>	<b style="color: blue">wed</b><br><br>The variable <b style="color: blue">day</b> takes each value in turn.<br><br>Note that <a href="index.html#foreach">foreach</a> does consider the index where <b style="color: blue">days</b> currently points to!<br><br>Links: <a href="index.html#foreach">foreach</a><br><br><a href="#top">top</a></pre><h2 id="15">8. Some common tasks with series: sort, find, modify etc.</h2><pre><br>Here are some typical tasks that you might need to do on series.<br>The details of the individual series functions are covered separately.<br><br><a href="#top">top</a></pre><h2 id="16">8.1. How to sort a series</h2><pre><br>Example:<br><br>	red>> days: ["sun" "mon" "tue" "wed"]<br>	== ["sun" "mon" "tue" "wed"]<br><br>	red>> sort days<br>	== ["mon" "sun" "tue" "wed"]<br><br>Note that the original series is modified!<br><br>Links: <a href="index.html#sort">sort</a><br><br><a href="#top">top</a></pre><h2 id="17">8.2. How to find a value in a series</h2><pre><br>The find function returns a reference to the series, at the found position<br><br>	red>> days: ["sun" "mon" "tue" "wed"]<br>	== ["sun" "mon" "tue" "wed"]<br><br>	red>> find days "tue"<br>	== ["tue" "wed"]<br><br>Links: <a href="index.html#find">find</a><br><br><a href="#top">top</a></pre><h2 id="18">8.3. How to insert a substring into a string</h2><pre><br>Example:<br><br>	red>> letters: "abcdefg"<br>	== "abcdefg"<br><br>	red>> insert find letters "d" "XX"<br>	== "defg"<br><br>	red>> letters<br>	== "abcXXdefg"<br><br>Links: <a href="index.html#insert">insert</a><br><br><a href="#top">top</a></pre><h2 id="19">8.4. How to replace a substring with another string</h2><pre><br>Example:<br><br>	red>> letters: "abcdefgabcdefgabcdefg"<br>	== "abcdefgabcdefgabcdefg"<br><br>	red>> replace letters "cd" "CD"<br>	== "abCDefgabcdefgabcdefg"    <b style="color: green">; only the first occurrence is changed</b><br><br>	red>> letters<br>	== "abCDefgabcdefgabcdefg"<br><br>In order to replace all occurrences, do:<br><br>	red>> letters: "abcdefgabcdefgabcdefg"<br>	== "abcdefgabcdefgabcdefg"<br><br>	red>> replace/all letters "cd" "CD"<br>	== "abCDefgabCDefgabCDefg"<br><br>	red>> letters<br>	== "abCDefgabCDefgabCDefg"<br><br>Links: <a href="index.html#replace">replace</a><br><br><a href="#top">top</a></pre><h2 id="20">8.5. How to append an item to a series</h2><pre><br>Example:<br><br>	red>> s: [1 2 3]<br>	== [1 2 3]<br><br>	red>> append s 4<br>	== [1 2 3 4]<br><br>	red>> s<br>	== [1 2 3 4]<br><br>Links: <a href="index.html#append">append</a><br><a href="#top">top</a><br><br></pre><h2 id="21">8.6. How to get a substring from a series </h2><pre><br>Here we use a string value, but code works with any type, of course.<br> <br>    &gt;&gt; s: "ABCDEFGH"<br>    == "ABCDEFGH"<br>    &gt;&gt; copy/part at s 2 4    ;-- start at position 2, get 4 items<br>    == "BCDE"<br><br><a href="#top">top</a><br></pre><h2 id="22">8.7. How to join strings</h2><pre><br>If you want to add a string to the end of an existing string, you can use<br>append, as above.  If you want to join literals, calculations etc, in a more<br>flexible way, consider <a href="index.html#rejoin">rejoin</a>, as in<br><br>    &gt;&gt; shape: " square "<br>    == " square "<br>    &gt;&gt; side: 6<br>    == 6<br>    &gt;&gt; rejoin ["The" shape "is " side * side " sq Units"]<br>    == "The square is 36 sq Units"<br><br>Each item is evaluated (reduced), then joined.<br><!----------------------------------------------------------------------------></td></tr></table></center></body></html>