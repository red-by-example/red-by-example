<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional"><html><head><meta http-equiv="content-type" content="text/html;charset=iso-8859-1"><title>Red by Example</title><style type="text/css">html, body, p, td, li {font-family: arial, sans-serif, helvetica; font-size: 10pt;}h1 {font-size: 16pt; Font-Weight: bold;}h2 {font-size: 14pt; color: #2030a0; Font-Weight: bold; width: 100%;    border-bottom: 1px solid #c09060;}h3 {font-size: 12pt; color: #2030a0; Font-Weight: bold;}h4 {font-size: 10pt; color: #2030a0; Font-Weight: bold;}h5 {font-size: 10pt; Font-Weight: bold;}tt {font-family: "courier new", monospace, courier; color: darkgreen;}pre {font: bold 10pt "courier new", monospace, console;    background-color: #f4f6f6; padding: 16px; border: solid #a0a0a0 1px;}.toc1 {margin-left: 1cm; font-size: 12pt; font-weight: bold;}.toc2 {margin-left: 2cm; font-size: 10pt; font-weight: bold; text-decoration: none;}.toc3 {margin-left: 3cm; font-size: 10pt; text-decoration: none;}.toc4 {margin-left: 4cm; font-size: 10pt; color: grey; text-decoration: none;}.output {color: #000080; font-weight: normal;}.note {background-color: #f0e090; width: 100%; padding: 16px; border: solid #a0a0a0 1px;}.tail {color: gray; font-size: 8pt;}.mike-large{color:blue; font-size: 13pt; font-weight:bold; }  .mike-small{ font-size: 10pt; }</style></head><body bgcolor="white"><center><table width="660" cellpadding="4" cellspacing="0" border="0"><tr><td><!----------------------------------------------------------------------------><h1 style="color:red; id=top">Red by Example - an accessible reference by example</h1>Last update on 20-Dec-2019<h2>parse</h2><pre><a href="index.html">index</a>     <a href="parse.html">parse</a>     <a href="vid.html">vid</a>     <a href="series.html">series</a>     <a href="draw.html">draw</a>     <a href="help.html">help</a>     <a href="about.html">about</a>     <a href="links.html">links</a>     <a href="contact.html">contact</a>     </pre><pre><a href="#1">1. PARSE IN RED</a><br><a href="#2">1.1. About The Parse Dialect</a><br><a href="#3">1.2. Parsing - An Introduction</a><br><a href="#4">1.3. Getting Started</a><br><a href="#5">1.4. Sequence, selection, repetition: Some, Any, |</a><br><a href="#6">1.5. Characters, Numbers, Names</a><br><a href="#7">1.6. Calculator Example With Strings</a><br><a href="#8">1.7. Inserting Red Code:  (  ) ,  Copy, Set</a><br><a href="#9">1.8. Calculator With Block Type: Copy And Set</a><br><a href="#10">1.9. Literal Types In String Input</a><br><a href="#11">2.1. Keywords inside/outside Parentheses</a><br><a href="#12">2.2. Skipping Input: Skip, To, Thru</a><br><a href="#13">2.3. Using Variable:</a><br><a href="#14">2.4. Using :Variable</a><br><a href="#15">2.5. Using a Variable</a><br><a href="#16">2.5. Remove, Insert, Change</a><br><a href="#17">2.6. Collect And Keep</a><br><a href="#18">2.7. Parse into/ahead (nested blocks)</a><br><a href="#19">3.1. Debugging - parse-trace</a><br></pre><h2 id="1">1. PARSE IN RED</h2><br></pre><h2 id="2">1.1. About The Parse Dialect</h2><pre><br>The 'parse'  facility of Red  helps us to  build  mini-languages (DSLs <br>- domain-specific languages). It lets us specify syntax, and also provides <br>a simpler alternative to regular expressions when processing strings.  <br>Parse is built-in to Red, so we can use it as part of a larger Red  program.<br><br>Here is an example showing how simple and lightweight it can be: we have a <br>2-character string, which should contain a product code of the form "A", <br>"B" or "C" followed by either "1", "2", or "3", such as "A2" or "C3".  The <br>following code does the validation, and Parse returns false if the string <br>is incorrect:<br><br>product: "C3"<br>parse/case product [["A" | "B" | "C"] ["1" | "2" | "3" ]] ;-- '|' means 'or'<br><br>The input to Parse is a series (the data we are processing in some way) and <br>a set of grammar rules.<br><br>The rules are similar to BNF specifications, but can also contain Red code <br>and commands to copy and skip through the input.<br><br>Though Parse has things in common with compiler-compilers, it has no <br>built-in facilities for e.g. symbol-table handling.  It is  simpler to use, <br>however.  In fact, major parts of Red are themselves created with Parse, <br>such as Draw and Vid.<br><br>In these notes, I will look at string and block input series, though <br>any <a href="index.html#seriesxex">series!</a> types are allowed, except <a href="index.html#imagexex">image!</a> and <a href="index.html#vectorxex">vector!</a>.<br><br>If your input format has nothing to do with Red (e.g. HTML files, exported <br>spreadsheets, strings from  a data-entry form, etc.) then you will use <br>string input to Parse.  For some tasks, there might be lots of low-level <br>rules, such as stating that an integer consists of several digits, or that <br>a series of  spaces separates items.<br><br>On the other hand, the really interesting stuff is to build a DSL to be<br>used within Red.  If your input is blocks of Red, then Parse works at a <br>higher level.  It knows that spaces separate items, and that 03:10:15 is a <br>time, for example.  In fact most of the literal types are recognised.  This <br>is normally the approach used to build a DSL. <br><br>Red is heavily based on REBOL of course, and Red's Parse has extra features <br>over REBOL 2's version.  REBOL users please note that the string-split <br>feature in REBOL 2 has been moved from Parse into a separate <a href="index.html#split">split</a> <br>function, and that parse in Red is the same as parse/all in REBOL.<br><br><br>For more information on Parse:<br><br>Introducing Parse, by Nenad Rakocevic.<br><a href="http://www.red-lang.org/2013/11/041-introducing-parse.html"><br>http://www.red-lang.org/2013/11/041-introducing-parse.html</a><br><br>The Parse chapter, from the REBOL 2  documentation:<br><a href="http://www.rebol.com/docs/core23/rebolcore-15.html"><br>http://www.rebol.com/docs/core23/rebolcore-15.html</a><br><br><a href="#top">top</a></pre><h2 id="3">1.2. Parsing - An Introduction</h2><pre><br>The syntax rules for programming languages are often specified in some kind <br>of BNF.  <br>Basically, we need to create  rules which express:<br><br>** sequence: one item is followed by another item.<br><br>**  choice: an item can be a selection from several things.<br><br>** repetition:  an item can be made from  a repetition of items.  Sometimes <br> it is helpful to be able to express 'one or more of' and 'zero or more of'.<br><br>** sub-rules.  It is convenient to express sub-rules, breaking up complex <br> syntax into manageable chunks.  Sometimes it is useful to use recursive <br> rules for nested input.<br><br>Here is how these concepts occur in a fragment of a BASIC-style language:<br><br>    if a&lt;b then c=42<br>    print "values ", a, b+2, c<br><br>Informally, we can say:<br><br>** A program consists of any number of statements.<br><br>** An 'if-statement' is a sequence of "if", a condition, "then", and a <br> statement.<br><br>** A 'print-statement' is a sequence.  It starts with the word "print", and <br> is followed by any number of items, with a "," between them.  Each item is <br> a selection from a quoted string and a numeric expression.<br><br>We would probably write sub-rules (sometimes called 'classes' in <br>syntax-analysis) for a statement, a print-statement, an if-statement, a <br>numeric-expression etc.  This simplifies things for humans, and allows <br>re-use for commonly-occurring items.<br><br>Now we will look at some Parse examples.<br><br>  <br><a href="#top">top</a></pre><h2 id="4">1.3. Getting Started</h2><pre><br>Here is a tiny Red program which uses Parse:<br><br>    Red [ "Parsing"]<br>    parse-rules: ["move-" "north"]   ;-- sequence<br>    input: "move-north"<br>    print parse input parse-rules    ;-- prints true<br><br>    input: "move-south"<br>    print parse input parse-rules    ;-- prints false<br><br>It begins with Red[ ], like all Red programs.  We will omit this in the <br>following code fragments.<br><br>Parse is a function which returns <a href="index.html#true">true</a> if its input matches the rules, <br>otherwise <a href="index.html#false">false</a>.    <br><br>If we wanted to allow any direction, we could write a sub-rule.  We choose <br>a name for it (using Red's rules for naming), and use  [   |   |   |   ....  <br>] for a choice:<br><br>    parse-rules: ["move-" direction]<br>    direction: ["north" | "south" | "east" | "west"]  ;-- choice<br>    input: "move-south"<br>    print parse input parse-rules   ;-- true<br><br>Note that string-matching is case-insensitive.  For case-sensitive <br>matching, use the /case refinement.<br><br>We could have written the above as:<br><br>    parse-rules: ["move-" ["north" | "south" | "east" | "west"]]<br>    input: "move-south"<br>    print parse input parse-rules <br><br>but a sub-rule provides  manageable chunks for humans.<br><br>With string input, spaces and newlines have no special significance.  For <br>example, if we want a space to be a separator, we must say so in the <br>rules.  With block input, things are different - this is covered later.<br><br><a href="#top">top</a></pre><h2 id="5">1.4. Sequence, selection, repetition: Some, Any, |</h2><pre><br>Whether the input is a string or a block, the action of these words is <br>identical.  To specify a sequence, we write:<br><br>    [item1  item2  item3  etc...]<br><br>'Item' can be primitive thing, or can be a sub-rule.<br><br>To specify a selection, we write:<br><br>    [item1 | item2 | item3 | etc...]<br><br>To specify repetition, we write:<br><br>    [some[ item1 item2 item3 etc]]<br><br>'some' requires at least one occurrence. <br><br>Note that we can write such rules as:<br><br>    [some "A" "B"]<br><br>but here, 'some' only applies to the first item, matching "AB"  "AAB" etc, <br>but not "ABAB". I will opt for always using [ ] for 'some', even if they <br>only enclose one item.<br><br>We can also use 'any', which specifies zero or more repetitions, as in:<br><br>    [any["A" "B"]]   ;-- e.g. "ABAB"  "AB"  ""<br><br>'Some' and 'any' will terminate when they encounter  an item that does not <br>match, so in the case of some["A" "B"]<br><br>** "ABABABC" input  -  'some' will match "AB" then "AB" etc. successfully, <br> then terminate when it reaches "C"<br><br>** "C" input  -  'some' will not match because there are no "AB"s .  If we <br> used 'any', the match would succeed, terminating on "C".<br><br>There are other convenient forms of rules, as in:<br><br>[3 "A"]       - a count, matches "AAA" only.<br>[1 3 "A"]     - a range, matches "A" or "AA"  or "AAA".<br>[0 3 "A"]     - a range, but zero occurrences are matched, as in "".<br>["A" | none]  - a selection, matching "A" or "".<br>              - This lets us detect a missing "A" specifically.<br><br><br><a href="#top">top</a></pre><h2 id="6">1.5. Characters, Numbers, Names</h2><pre><br>This is the relatively low-level (lexical analysis) area.  We can specify, <br>for example, than an integer is a series of digits (at least one).  We can <br>make use of <a href="index.html#charsetxex">charset!</a>:<br><br>    digit: charset "0123456789" ;-- any of these. (could also use  '-'<br>    integer: [some digit]       ;-- one or more<br><br>Charset! is often used for speed reasons.  We could also have used the <br>slower:<br><br>    digit: [ "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" <br>]<br>Here is how we can specify a typical variable name, which starts with a <br>letter, then has letters or digits following:<br><br>letter: charset [#"A" - #"Z" #"a" - #"z"]  ;-- A to Z  and a to z<br>alpha-numeric: [letter | digit]<br>var-name: [letter [any [alpha-numeric]]]<br><br>(We can use the set functions 'union',  'intersect' etc for higher speed).<br><br><a href="#top">top</a></pre><h2 id="7">1.6. Calculator Example With Strings</h2><pre><br>Here is a toy example.  A calculation is made up of +, -, a memory (mem), <br>and  integers.  Some calculations:<br><br>    +33-22<br>    -44<br>    +55+22-56+mem+1<br><br>There are 2 types of statement: memory and display, as in<br><br>    mem=+33+55<br>    display mem+100<br><br>There are no extra spaces, and a statement is followed by a newline.  Of <br>course, we can write such calculations in straight Red - this is merely an <br>example of parsing.  Here is one possible set of parse rules, followed by <br>some code in our tiny language:<br><br>program: [some [statement] ]        ;-- at least one statement<br>statement: [[mem-instruction | display-instruction] newline]<br>mem-instruction: ["mem=" calculation]<br>display-instruction: ["display" space calculation]<br>calculation: [[some[pair]]] <br>pair: [operator primitive]          ;-- all primitives preceded by op<br>operator: [ "+" | "-"] <br>primitive: [ num |"mem" ] ;-- e.g. 123, mem<br>digit: charset "0123456789"<br>num: [1 6 digit ]                   ;-- 1 to 6 digits in a num<br><br>code: {mem=+3-4+1<br>mem=+mem+1<br>display -100-mem+101<br>}<br><br>either parse code program [<br>    print "Checked OK"<br>] [<br>    print "Error"<br>]<br><br>Some points about the rules:<br><br>** program: we used 'some'.  This disallows programs with no statements.  <br> If we wanted, we can specifically check this case using 'none', perhaps to <br> display a targetted error message.  The rule would then be<br><br>    program: [some [statement] | none ] <br><br>** statement: there are two types, either must be followed by a newline.  <br> Note that space and newline are pre-defined values in Red.<br><br>** calculation: most of the work is done here.  The smallest legal <br> calculation is e.g. +3.   A calculations consists of 'some' pairs, in which <br> a pair is an operator (only '+' and '-' in this version) followed by a <br> primitive item.<br><br>** primitive:  either a 6-digit number, or the text "mem".  We are using <br> string input here, and we allow a maximum of 6 digits.  But what about <br> floating-point?  We could try to write the syntax for this, but a better <br> approach would be to use block input, and let Red recognise the types it <br> already knows about.  This is shown later. <br><br>** I could have used less rules, but personally I find the extra names <br> improves clarity.<br><br><a href="#top">top</a></pre><h2 id="8">1.7. Inserting Red Code:  (  ) ,  Copy, Set</h2><pre><br>We can insert Red code in our rules by enclosing it in parentheses.  For <br>example, if we modify our calculator 'num' rule to:<br><br>    num: [1 6 digit (print "got num")]   <br><br>we will see "got num" displayed 4 times with our input of<br><br>in: {mem=+3+1234<br>display -4+3-mem<br>}<br><br>Note that if the rule is entered, but no match happens, code at the end of <br>the rule is not executed.  At the console, for example:<br> <br>&lt;&lt; rule: [(print "A") "start" (print "B") ]  ;-- match "start"<br>&lt;&lt; parse "start" rule       <br>A<br>B<br>== true                 ;-- matches OK<br><br>&lt;&lt; parse "st-art" rule<br>A<br>== false                ;-- no match, B not displayed<br><br>Similarly, in a selection, if we have<br><br>some-rule: ["begin" | "end"]<br><br>and we add some code like this:<br><br>some-rule: ["begin" | "end" (print "In some-rule") ]<br><br>it will only be executed when "end" is matched.  To see the message in <br>either case, we should also put it immediately after "begin".<br><br>Within (...) we can put any Red code, such as using variables and calling <br>functions.<br><br>The 'copy' word can be used to access the matched text.  It is followed by <br>a variable name, and must directly precede a rule.  (i.e. don't put any <br>bracketed code between 'copy' and a rule.  Here is an example:<br><br>    num: [copy number 1 6 digit (print[ "number: " number]) ]<br>    digit: charset "0123456789"<br>    parse "123" num<br><br>The rule is '1 6 digit', and it is preceded by a copy.  We are free to <br>choose the variable name for copy.  When the rule succeeds (as it does <br>above)  the print is executed, showing  123.<br><br>Here is another example:<br><br>    operator: [copy  op "+" | copy op "-"]<br><br>Note the copy in each selection.  Our 'op' variable can be referred to in <br>another rule.  Later we will use 'set', which is similar to 'copy'.<br><br>There is also  a 'copy' in Red, but the Parse copy is different.<br><br>Here is the same grammar, with 'copy' and parenthesised code used to <br>perform the execution:<br><br>total: 0<br>memory: 0<br>use-num: func [] [<br>    either op = "-" [;-- update the total   + or -<br>        total: total - to integer! prim<br>    ] [<br>        total: total + to integer! prim<br>    ]<br>]<br><br>program: [some [statement]]<br>statement: [[mem-instruction | display-instruction] newline]<br>mem-instruction: ["mem=" calculation (memory: total)] ;-- update memory<br>display-instruction: <br>    ["display" space calculation (print ["display:  " total])]<br>calculation: [(total: 0) [some [pair]]] ;-- initialise the calculation<br>pair: [operator primitive]<br>operator: [copy op "+" | copy op "-"] ;-- remember the op<br>primitive: <br>    [copy prim num (use-num) | copy prim "mem" (prim: memory use-num)]<br>digit: charset "0123456789"<br>num: [1 6 digit]<br><br>code: {mem=+3-4+1<br>mem=+mem+1<br>display -100-mem+101<br>}<br>print "Code:"<br>print code<br><br>either parse code program [<br>    print "Checked OK"<br>] [<br>    print "Error"<br>]<br><br>and here is the output:<br><br>    Code:<br>    mem=+3-4+1<br>    mem=+mem+1<br>    display -100-mem+101<br>    display:   0<br>    Checked OK<br><br>A function was used to do the addition or subtraction, but similar code <br>could have been embedded in the rules.<br><br>Finally, we will put some calculator code in a file, and read it in. We <br>create a file named (for example) calc-code.txt, and put our code there, as <br>in:<br><br><br>mem=+3-4+1<br>mem=+mem+1<br>display -100-mem+101<br><br>Now we modify our program to read the file:<br><br>    code: read %calc-code.txt    ;-- in Red, % identifies a file name<br>    parse code program<br><br><a href="#top">top</a></pre><h2 id="9">1.8. Calculator With Block Type: Copy And Set</h2><pre><br>The above calculator worked, but the use of 6-digit integers was <br>unrealstic.   Also, what if we wanted to change our calculator to work with <br><a href="index.html#floatxex">float!</a> or <a href="index.html#timexex">time!</a> types?  Their syntax is not simple.  In such <br>situations, we would use block input.   Here is some input for the block <br>version:<br><br>code: [mem = + 4 - 4 + 1<br>mem = + mem + 1<br>display - 100 - mem + 101<br>]<br><br>We have to put spaces between items now.  In fact, the input code is now <br>quite close to Red, and  there are various ways of interpreting it.  <br>However, we will continue with Parse, and compare  it to the string version <br>above.  Here is the Parse code:<br><br>memory: 0<br>total: 0<br>use-num: func [] [<br>    either op = '- [ <br>        total: total - prim<br>    ] [<br>        total: total + prim<br>    ]  <br>]<br>     <br>program: [some [statement]]<br>statement: [[mem-instruction | display-instruction]]<br>mem-instruction: ['mem '= calculation (memory: total)]<br>display-instruction: ['display calculation (print ["display: " total])]<br>calculation: [(total: 0) [some [pair]]]<br>pair: [operator primitive]<br>operator: [set op '+ | set op '- ]<br>primitive: <br>    [set prim integer! (use-num) | set prim 'mem (prim: memory use-num)]<br><br>The differences from the string version are:<br><br>** we have removed references to space and newline.  We use the Red <br> approach of spaces separating items.<br><br>** the 'primitive' rule now uses the Red <a href="index.html#integerxex">integer!</a> type.  All literal <br> types (e.g. <a href="index.html#pairxex">pair!</a>, <a href="index.html#timexex">time!</a>, <a href="index.html#floatxex">float!</a> etc can be similarly matched.  <br> We can use <a href="index.html#any-typexex">any-type!</a> to match any item in the input.<br><br>** to match a word - such as mem, we use 'mem.  Word matching is <br> case-insensitive.<br><br>** we used 'set' rather than 'copy'.  In the above, the 'copy' variable is <br> made into  a series type, even if it holds a single item, whereas the type <br> of the 'set' variable is what we want here (i.e <a href="index.html#integerxex">integer!</a> in the <br> 'primitive' match).<br><br>Strictly, the value of 'copy' is the collection of matched items, whereas <br>'set' uses the first matched item.  Here are two examples<br><br>    parse "Stuff---" ["Stuff" copy d some "-" (print [type? d d])]<br>    parse "Stuff---"  ["Stuff" set d some "-" (print [type? d d])]<br><br>In the first example, 'copy' contains the whole match "---" as a string, <br>and in the second, 'set' contains the first matched item as the character <br>#"-".<br><br>Here are some copy/set examples using blocks:<br><br>parse [Stuff 12 34] ['Stuff copy matched some integer!<br>   (print [type? matched matched])]<br>parse [Stuff 12 34] ['Stuff set matched some integer!<br>   (print [type? matched matched])]<br><br>The output is:<br><br>block 12 34 <br>integer 12<br><br>We can also read data from a file into a block with <a href="index.html#load">load</a>, and use it <br>directly in Parse, as in:<br><br>    parse   load %block-in.txt program<br><br>Where block-in.txt holds:<br><br>mem = + 4 - 4 + 1<br>mem = + mem + 1<br>display - 100 - mem + 101 - 2222<br><br><a href="#top">top</a></pre><h2 id="10">1.9. Literal Types In String Input</h2><pre><br>Parse rules used with strings cannot contain type names (<a href="index.html#pairxex">pair!</a>, <br><a href="index.html#integerxex">integer!</a>, <a href="index.html#floatxex">float!</a> etc). However, some literal values (not type <br>names) can be used.  These are <a href="index.html#urlxex">url!</a>, <a href="index.html#emailxex">email!</a>, and <a href="index.html#tagxex">tag!</a>.  Tag <br>values are the most common, as they are useful in HTML processing.  Here <br>are some examples.  They are all 'true':<br><br>    print parse "Stuff&gt;atag&lt;" ["Stuff" &gt;atag&lt;]<br>    print parse "Stuffhttp://me.com" ["Stuff" http://me.com]<br>    print parse "Stuffme@super.org" ["Stuff" me@super.org]<br><br>Note the reduction of quotes in the rules, though we could also use:<br><br>    print parse "Stuff&gt;atag&lt;" ["Stuff" "&gt;atag&lt;"]<br> <br><a href="#top">top</a></pre><h2 id="11">2.1. Keywords inside/outside Parentheses</h2><pre><br>We have seen that rules can contain Red code in parentheses, and also <br>commands - such as 'copy' outside parentheses.  There are a number of other <br>commands (keywords) that belong to Parse.  Sometimes they have the same <br>name as Red words, but they belong to Parse, and in general they have a <br>different meaning.  You have seen 'copy', 'set', 'some', 'any', etc and now <br>we will look at others.  Many of them allow us to manipulate the input <br>series.<br><br>A full list is available in:<br>Introducing Parse, by Nenad Rakocevic.<br><a <br>href="http://www.red-lang.org/2013/11/041-introducing-parse.html">http://www.<br>red-lang.org/2013/11/041-introducing-parse.html</a><br><br><a href="#top">top</a></pre><h2 id="12">2.2. Skipping Input: Skip, To, Thru</h2><pre><br>These words let us move through the input.  <br><br>'Skip'  - this skips one item in the input series.  For example:<br><br>    rule: ["a" skip "b"]<br>    print parse "axb" rule        ;-- true<br><br>Above, the rule states:<br>    - match an "a"<br>    - skip over any character<br>    - match a "b"<br><br>Using the above rule with different data:<br><br>    print parse "axc" rule       ;-- false - no b<br>    print parse "axxb" rule      ;-- false - no a after first x<br><br>Here is a block input example, which matches an integer, skips the next <br>item (an integer here), then matches a string.  Parse returns 'true':<br><br>    print parse [123 456 "Hello"] [integer! skip string! ]<br><br>Now some more 'skip' examples, all true, using a range:<br><br>    print parse "axxxb" ["a" 1 3 skip "b"]   ;-- a, do 3 skips, b<br>    print parse "xxxa" [3 skip  "a"]         ;-- 3, skips, a<br><br>The 'thru' facility skips up to  a specified item, as in:<br><br>    parse "axxxbc" ["a" thru "b" "c"] ;--true: a, skip to b inclusive, c<br><br>In the above, 'b' is also skipped, and matching continues after it.<br><br>Note that this also works for multi-character strings in rules, as in:<br><br>    parse "axxxxxbeec" ["a" thru "bee" "c"]  ;-- skips to bee, matches c <br><br>and from the start, here using a sub-rule:<br><br>    animal: ["black " "cat"]<br>    parse "whatever---black cat" [thru animal]        ;-- true<br><br>Alongside 'thru' there is the similar 'to', which does not include the item <br>which ends the skip.  In the following example, the first 'b' is detected <br>but is not part of the skip.  The second 'b' in the rule will match it:<br><br> parse "axxxxxb" ["a" to "b" "b" ]    ;--  up to b, not including it.<br><br>Here is an example which copies the title of a web page:<br><br>html-code: "&gt;html&lt; &gt;title&lt;My Great Page&gt;/title&lt; Contents <br>here... &gt;/html&lt;"<br>parse html-code [thru &gt;title&lt; copy the-title  to &gt;/title&lt;]<br>print ["Title is: " the-title]    ;-- prints:   My Great Page<br><br>We used the tag type in the rule, but could have used e.g. <br>"&gt;title&lt;".  Note the use  of  'to'.  If we used 'thru', then the <br>result is:  <br><br>My Great Page&gt;/title&lt; <br><br> .top<br></pre><h2 id="13">2.3. Using Variable:</h2><pre><br>We can  create a variable, and set its value.  This is a Parse feature.  <br>Here are some examples.  First we look at getting a position in the series:<br><br>parse "ABCDEFG" [thru "D" place: (print place) ]     ;-- EFG printed<br><br>We created the 'place:' variable.  Here, we skip to "D", including it.  <br>Then, 'place' becomes a reference to the current input position.  Here, <br>this is from "E" to the end.<br>	<br>Here is an example which finds the positions of items between START and <br>STOP.  It uses the <a href="index.html#indexxqm">index?</a> series function to get a numeric position <br>from the reference to the series.<br><br>    parse [A B START C D E STOP F G] [<br>        thru 'START pos1: to 'STOP pos2: <br>           (print [index? pos1 "-" (index? pos2) - 1 ])  ;-- prints 4 - 6<br>    ]    <br><br>If we display the two positions as references without using <a href="index.html#indexxqm">index?</a>, we <br>would get:<br><br>    C D E STOP F G - STOP F G<br><br>Here is another example of finding positions, this time in HTML text.  We <br>are interested in &gt;h1&lt; items.<br><br>page: {&gt;html&lt; &gt;title&lt; My Great Page&gt;/title&lt;<br>&gt;h1&lt; Big Heading A&lt;&gt;/h1&lt;&gt;p&lt;Stuff in  A &gt;/p&lt;<br>&gt;h1&lt; Big Heading B&lt;&gt;/h1&lt;&gt;p&lt;Stuff in  B &gt;/p&lt;<br>&gt;/html&lt;<br>    }<br><br>;-- positions of text in  an h1<br>parse page [ any [thru &gt;h1&lt; h1-at: (print ["h1 at: " index? h1-at])]]<br>;-- position of the &gt; in &gt;h1&lt;<br>parse page [ any [to "&gt;h1" h1-at: thru "&lt;" (print ["h1 at: " index? <br>h1-at])]]<br><br>The first example uses an unquoted tag in the rule, and 'thru' includes the <br>whole tag.<br><br>The second example uses a quoted string to find "&gt;h1", notes the <br>position, then moves to the closing "&lt;".  <br><br>Note that if we try to do the second example with 'to', as in:<br><br>    any[ to &gt;h1&lt; ...]<br><br>Then parse gets stuck, repeatedly finding the same &gt;h1&lt;.<br><br><a href="#top">top</a></pre><h2 id="14">2.4. Using :Variable</h2><pre><br>Here we look at modifying the input series.  This example finds the start <br>and end of the page's title text, and uses these references to modify the <br>input series:<br><br>    parse page [thru &lt;title&gt; begin: to &lt;/title&gt; ending:<br>        (change/part begin "A Better Title" ending) <br>    ]<br> <br><br><a href="#top">top</a></pre><h2 id="15">2.5. Using a Variable</h2><pre><br>We have looked at the use of ':word' and  'word:'.  If we use a word <br>without a colon, its value is looked up and used, as in:<br><br>    a-word: 3<br>    print parse "xxxa" [a-word skip  "a"]      ;-- true<br><br>We could use this approach for counts, match-values etc.<br><br><a href="#top">top</a></pre><h2 id="16">2.5. Remove, Insert, Change</h2><pre><br>These Parse keywords modify the input series.  They can be more convenient <br>than using Red code in parentheses.<br><br>We can remove the matched input, as in:<br><br>    inp: "XXX-------"<br>    parse inp [any "X" remove any "-"]           ;<br>    print inp          ;-- prints XXX<br><br>We can insert an item (e.g. a string, a block) at current input position.  <br>Scanning continues past the insertion.<br><br>    inp: "XXX-------"<br>    parse inp [any "X" insert "ABC" any "-"]           ;<br>    print inp           ;-- prints XXXABCabc-------<br><br>We can change the match input to  a given value:<br><br>    inp: [12 "a string" "b string" 22 44]  ;-- unordered strings,  integers<br>    parse inp [some[string! |  change integer! "NUMBER" ]]<br>    print inp<br>    print ""<br><br>The output is:<br><br>   NUMBER a string b string NUMBER NUMBER<br><br><a href="#top">top</a></pre><h2 id="17">2.6. Collect And Keep</h2><pre><br>Parse has its own <a href="index.html#collect">collect</a> and <a href="index.html#keep">keep</a> functions, similar to those in Red. <br>Here we parse a block of various types of item, and keep only the <br>integers.  Keep can be used several times.  Note that we match an integer <br>before the more general <a href="index.html#any-typexex">any-type!</a>.  There is also  a 'pick' option for <br>'keep', which allows control over the storing of the selection.<br><br>    in: [12 3x44 "a string" 13  a-word 14]<br>    ;-- prints 12 13 14<br>    print parse in [collect[some[ keep integer! | any-type!]]] <br>The 'collect' function returns a block via Parse, i.e. the normal Parse <br><a href="index.html#logicxex">logic!</a> result is not returned.<br><br><br><a href="#top">top</a></pre><h2 id="18">2.7. Parse into/ahead (nested blocks)</h2><pre><br>Programming languages usually have some way of delimiting nested code, such<br>as curly-brackets in C++, Java.  It is possible that your DSL might need nested<br>items.  We can make use of Red's square brackets for this.  Here is an example of<br>a nested structure. We can make the parser go into nested blocks with 'into'.<br><br>First we look 'ahead' to see if the next item is a block.<br><br>    ;-- a series of:    integers or nested integers<br>    list: [22 33 [44 [55] 66] 77]<br><br>    nested-rule: [ any[ item ]]<br>    item: [copy num integer! (print num)<br>           | ahead block! (print "got a block")<br>             into nested-rule (print "out of block")]<br>    parse list nested-rule<br><br>The output is:<br><br>    33<br>    got a block<br>    44<br>    got a block<br>    55<br>    out of block<br>    66<br>    out of block<br>    77 <br><br><a href="#top">top</a></pre><h2 id="19">3.1. Debugging - parse-trace</h2><pre><br>To look into how your rules are working, you can insert printing to provide <br>a trace, as in:<br><br>    primitive: [ num | "mem" ]               ;-- original rule<br>    ;-- with prints<br>    primitive: [num (print "got num") | "mem" (print "got mem")]<br><br>You can also use the 'parse-trace' wrapper for Parse, as in:<br><br>    parse-trace some-input  a-rule<br><br>This displays a detailed trace of the parse process.<br><br><!----------------------------------------------------------------------------></td></tr></table></center></body></html>